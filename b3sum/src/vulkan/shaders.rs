// The shaders modules are manually written, instead of using vulkano-shaders,
// for the following reasons:
//
// 1. It allows using Vulkan libraries other than Vulkano;
// 2. It makes sure every user of the library uses the exact same SPIR-V code;
// 3. Currently, Vulkano does not have a flag to enable SPIR-V optimizations.
//
// Additionally, the code generated by vulkano-shaders is currently defective;
// for instance, it marks the output buffer as readonly.

pub mod blake3 {
    use blake3::gpu::shaders;
    use std::ffi::CStr;
    use std::sync::Arc;
    use vulkano::descriptor::descriptor::{
        DescriptorBufferDesc, DescriptorDesc, DescriptorDescTy, ShaderStages,
    };
    use vulkano::descriptor::pipeline_layout::{PipelineLayoutDesc, PipelineLayoutDescPcRange};
    use vulkano::device::Device;
    use vulkano::pipeline::shader::{ComputeEntryPoint, ShaderModule};
    use vulkano::OomError;

    #[derive(Debug, Clone)]
    pub struct Shader {
        shader: Arc<ShaderModule>,
    }

    impl Shader {
        #[inline]
        pub fn load(device: Arc<Device>) -> Result<Shader, OomError> {
            unsafe {
                Ok(Shader {
                    shader: ShaderModule::new(device, shaders::blake3::shader())?,
                })
            }
        }

        #[inline]
        pub fn main_entry_point(&self) -> ComputeEntryPoint<(), Layout> {
            unsafe {
                self.shader
                    .compute_entry_point(CStr::from_bytes_with_nul_unchecked(b"main\0"), Layout)
            }
        }
    }

    #[derive(Debug, Clone)]
    pub struct Layout;

    unsafe impl PipelineLayoutDesc for Layout {
        #[inline]
        fn num_sets(&self) -> usize {
            1
        }

        #[inline]
        fn num_bindings_in_set(&self, set: usize) -> Option<usize> {
            match set {
                0 => Some(3),
                _ => None,
            }
        }

        fn descriptor(&self, set: usize, binding: usize) -> Option<DescriptorDesc> {
            debug_assert_eq!(shaders::blake3::INPUT_BUFFER_BINDING, 0);
            debug_assert_eq!(shaders::blake3::OUTPUT_BUFFER_BINDING, 1);
            debug_assert_eq!(shaders::blake3::CONTROL_UNIFORM_BINDING, 2);

            match (set, binding) {
                (0, 0) => Some(DescriptorDesc {
                    ty: DescriptorDescTy::Buffer(DescriptorBufferDesc {
                        dynamic: Some(false),
                        storage: true,
                    }),
                    array_count: 1,
                    stages: ShaderStages::compute(),
                    readonly: true,
                }),
                (0, 1) => Some(DescriptorDesc {
                    ty: DescriptorDescTy::Buffer(DescriptorBufferDesc {
                        dynamic: Some(false),
                        storage: true,
                    }),
                    array_count: 1,
                    stages: ShaderStages::compute(),
                    readonly: false,
                }),
                (0, 2) => Some(DescriptorDesc {
                    ty: DescriptorDescTy::Buffer(DescriptorBufferDesc {
                        dynamic: Some(false),
                        storage: false,
                    }),
                    array_count: 1,
                    stages: ShaderStages::compute(),
                    readonly: true,
                }),
                _ => None,
            }
        }

        #[inline]
        fn num_push_constants_ranges(&self) -> usize {
            0
        }

        #[inline]
        fn push_constants_range(&self, _num: usize) -> Option<PipelineLayoutDescPcRange> {
            None
        }
    }
}

#[cfg(any(test, target_endian = "big"))]
pub mod endian {
    use blake3::gpu::shaders;
    use std::ffi::CStr;
    use std::sync::Arc;
    use vulkano::descriptor::descriptor::{
        DescriptorBufferDesc, DescriptorDesc, DescriptorDescTy, ShaderStages,
    };
    use vulkano::descriptor::pipeline_layout::{PipelineLayoutDesc, PipelineLayoutDescPcRange};
    use vulkano::device::Device;
    use vulkano::pipeline::shader::{ComputeEntryPoint, ShaderModule};
    use vulkano::OomError;

    #[derive(Debug, Clone)]
    pub struct Shader {
        shader: Arc<ShaderModule>,
    }

    impl Shader {
        #[inline]
        pub fn load(device: Arc<Device>) -> Result<Shader, OomError> {
            unsafe {
                Ok(Shader {
                    shader: ShaderModule::new(device, shaders::endian::shader())?,
                })
            }
        }

        #[inline]
        pub fn main_entry_point(&self) -> ComputeEntryPoint<(), Layout> {
            unsafe {
                self.shader
                    .compute_entry_point(CStr::from_bytes_with_nul_unchecked(b"main\0"), Layout)
            }
        }
    }

    #[derive(Debug, Clone)]
    pub struct Layout;

    unsafe impl PipelineLayoutDesc for Layout {
        #[inline]
        fn num_sets(&self) -> usize {
            1
        }

        #[inline]
        fn num_bindings_in_set(&self, set: usize) -> Option<usize> {
            match set {
                0 => Some(2),
                _ => None,
            }
        }

        fn descriptor(&self, set: usize, binding: usize) -> Option<DescriptorDesc> {
            debug_assert_eq!(shaders::endian::INPUT_BUFFER_BINDING, 0);
            debug_assert_eq!(shaders::endian::OUTPUT_BUFFER_BINDING, 1);

            match (set, binding) {
                (0, 0) => Some(DescriptorDesc {
                    ty: DescriptorDescTy::Buffer(DescriptorBufferDesc {
                        dynamic: Some(false),
                        storage: true,
                    }),
                    array_count: 1,
                    stages: ShaderStages::compute(),
                    readonly: true,
                }),
                (0, 1) => Some(DescriptorDesc {
                    ty: DescriptorDescTy::Buffer(DescriptorBufferDesc {
                        dynamic: Some(false),
                        storage: true,
                    }),
                    array_count: 1,
                    stages: ShaderStages::compute(),
                    readonly: false,
                }),
                _ => None,
            }
        }

        #[inline]
        fn num_push_constants_ranges(&self) -> usize {
            0
        }

        #[inline]
        fn push_constants_range(&self, _num: usize) -> Option<PipelineLayoutDescPcRange> {
            None
        }
    }
}
